---
title: "Raspberry Pi IoT Image"
author: "Pia Bereuter"
date: today
other-links:
  - text: Kapitel PDF
    icon: file-pdf
    href: chapters/A4_Setup.pdf
code-links:
  - text: Installations Script
    icon: file-code
    href: data/install_iot_software.sh
  - text: requirements.txt
    icon: file-code
    href: data/requirements.txt
resources:
  - data/install_iot_software.sh
  - data/requirements.txt
---

Für eine möglichst reibungslose Durchführung der Übungen ist ein vorkonfiguriertes Image hilfreich. Dies gewährleistet, dass alle Studierenden mit der gleichen Software arbeiten und die Übungen nicht durch Installationsprobleme verzögert werden

Für die Übungen mit den Sensoren sind Python und die entsprechenden Sensorbibliotheken erforderlich. Die Installation dieser Bibliotheken ist in den Übungsanleitungen beschrieben. Die Übungen mit dem IoT Stack mit MQTT, InfluxDB, Node-Red und Grafana erfordern eine Installation der Software auf dem Raspberry Pi. Die Installation dieser ist nicht in der Übungsanleitung8 abgedeckt.

::: hint
**Hinweis**: Für das Kopieren mehrerer Images auf SD Karten können diese einzel auf die SD Karten geschrieben werden oder empfehlenswert für das Kopieren von mehreren SD Karten lohnt es sich auch eine SD Karten Kopierstation zu verwenden, wie z.B. die [Renkforce Speicherkarten-Kopierstation](https://www.digitec.ch/de/s1/product/renkforce-tragbares-sdmicrosd-flash-lesegeraet-mit-kopierfunktion-v-1-auf-2-von-speicherkartenlesege-14550270)
:::

## Raspberry Pi Zugangsdaten
Notiere die Zugangsdaten für den Raspberry Pi und die einzelnen Softwarekomponenten in der untenstehenden Tabelle. Die Zugangsdaten werden für die Übungen benötigt.

| Konto        | User | Passwort | Kommentar      |
|--------------|------|----------|----------------|
| Raspberry Pi |      |          |                |
| influxdb     |      |          | organisation:  |
| grafana      |      |          |                |

: Zugangsdaten zu den einzelnen Konten notieren, gerade bei Datenbanken geht dies leicht vergessen. {tbl-colwidths="[20,25,25,30]"}

## Installation Shell Script 
Shell Script für die Installation der erforderlichen Bibliotheken
Script `install_iot_software.sh` mit dem unten aufgeführten Code erstellen und dem Script die Rechte für die Ausführung setzen mit 

```bash
sudo chmod +x install_iot_software.sh
```
Script mit folgendem `sh install_iot_software.sh` oder `./install_iot_software.sh` Befehl ausführen:

::: hint
InfluxDB Version: Die Version der InfluxDB auf die neuste Version im Script anpassen.
:::

Shell Script: `install_iot_software.sh` - Bash Script zu Installation der Software und Libraries für das fächerübergreifende Modul 5200 IoT 
Installation von:

- Python Libraries Beispielcode für die Pimoroni Sensoren
- Klonen der Libraries mit Beispielen in Documents/Libraries 
- Jupyter Notebook
- MQTT, Mosquitto Broker und Clients
- Node-Red
- InfluxDB
- Grafana
- VNC

::: hint
**Zeilenumbrüche EOL**
Zeilenunterbrüche von Textdateien unterscheiden sich zwischen Unix `LF` und Windows `CRLF` Systemen. Bash Script müssen auf Linux Systemen Unix Zeilenumbrüche (EOL) `LF` aufweisen. Dies ist vor allem dann wichtig, wenn das Script auf einem Windows System erstellt wird. Windows verwendet standardmässig `CRLF` Zeilenumbrüche. In Visual Studio Code können die EOL Zeichen mit `Ctrl+Shift+P` und `Change End of Line Sequence` auf `LF` umgestellt werden oder über die Statusleiste unten rechts bei `CRLF`. In Notepad++ kann dies über `Edit/EOL Conversion/Unix (LF)` umgestellt werden.
:::

*install_iot_software.sh*: Bash Installations-Script mit Unix Zeilenumbrüchen EOL
```{.bash}
#!/bin/bash
COL='\033[0;32m' # Primary Color
NC='\033[0m' # No Color
echo "${COL}Raspberry Pi Version${NC}"
hostnamectl
cat /proc/cpuinfo | grep Model

echo "${COL}Raspberry Pi aktualisieren${NC}"
sudo apt update
sudo apt full-upgrade -y
sudo apt autoremove -y

echo "${COL}VNC Installation${NC}"
sudo apt-get install realvnc-vnc-server
sudo apt-get install realvnc-vnc-viewer

echo "${COL}i2c-tools Installation${NC}"
sudo apt install python3-smbus
sudo apt install -y i2c-tools

echo "${COL}Mosquitto Server, Clients und Python Libraries Installation${NC}"
sudo apt install mosquitto -y
sudo apt install mosquitto-clients -y
sudo systemctl enable mosquitto.service
sudo systemctl restart mosquitto

echo "${COL}Node-Red Installation${NC}"
curl -sL https://raw.githubusercontent.com/node-red/linux-installers/master/deb/update-nodejs-and-nodered -o update-nodejs-and-nodered.sh
chmod +x update-nodejs-and-nodered.sh
bash update-nodejs-and-nodered.sh --confirm-root --confirm-pi --confirm-install --no-init
rm update-nodejs-and-nodered.sh
sudo systemctl enable nodered.service
sudo systemctl start nodered.service

echo "${COL}InfluxDB Installation${NC}"
wget https://dl.influxdata.com/influxdb/releases/influxdb2-2.7.1-arm64.deb
sudo dpkg -i influxdb2-2.7.1-arm64.deb
sudo service influxdb start

echo "${COL}Grafana Installation${NC}"
sudo apt-get install -y apt-transport-https software-properties-common wget
sudo mkdir -p /etc/apt/keyrings/
wget -q -O - https://apt.grafana.com/gpg.key | gpg --dearmor | sudo tee /etc/apt/keyrings/grafana.gpg > /dev/null
echo "deb [signed-by=/etc/apt/keyrings/grafana.gpg] https://apt.grafana.com stable main" | sudo tee -a /etc/apt/sources.list.d/grafana.list
sudo apt-get update
sudo apt-get install grafana -y

sudo systemctl daemon-reload
sudo systemctl start grafana-server
sudo systemctl enable grafana-server.service
sudo apt autoremove -y

echo "${COL}Klonen der Pimoroni Python Bibliotheken${NC}"
echo "${COL}in Documents/Libraries${NC}"
cd Documents
mkdir Libraries
cd Libraries
git clone https://github.com/pimoroni/st7789-python
git clone https://github.com/pimoroni/bme680-python 
git clone https://github.com/pimoroni/icm20948-python
git clone https://github.com/pimoroni/as7262-python
git clone https://github.com/pimoroni/max30105-python
git clone https://github.com/pimoroni/vl53l5cx-python
git clone https://github.com/pimoroni/mlx90640-library
cd ../../
```

Zip Datei des Ordners Libraries erstellen für das Backup der Beispielcode der einzelnen Sensoren.

```bash	 
cd ~/Documents/
zip -r Libraries.zip Libraries
```


### Installation der Python Libraries mit *venv*
Mit dem Upgrade auf *Raspberry Pi Bookworm* wird Python auf die Version 3.11 aktualisiert. Ab dieser Version können Python Libraries nicht mehr systemweit installiert werden. *Python Virtual Environment* sind nun erfordert, entweder pro Projekt oder pro Userkonto siehe [http://rptl.io/venv](http://rptl.io/venv) für weitere Informationen.

Erstelle eine Python Virtual Environment `.env` im Homeordner `~/` mit folgenden Befehlen für den User `iot` und aktiviere die Virtual Environment mit `source ~/.env/bin/activate` und deaktiviere die Virtual Environment mit `deactivate`. Wenn die Virtual Environment projetbasiert im Projektordner erstellt wird reicht es den Pfad zum Projektordner anzugeben z.B. `python -m venv ~/Development/Projekt1/env` und die Virtual Environment wird im Projektordner erstellt.

```bash
python -m venv ~/.env
source ~/.env/bin/activate
```

Requirements.txt Datei erstellen mit den Python Libraries, die in der Virtual Environment installiert werden sollen. Die Datei kann mit `nano requirements.txt` erstellt und mit `Ctrl+o` und `Ctrl+x` gespeichert werden.
Python Libraries in der Virtual Environment installieren mit `pip install -r requirements.txt`. Nutze für die Installation folgende `requirements.txt` Datei. Kontrolliere mit `pip list` ob die Libraries installiert wurden.

*requirements.txt*: Python Libraries für die Pimoroni Sensoren
```{.txt}
smbus
matplotlib
scipy
pigments
numpy
jupyter
rpi.gpio
spidev
pillow
numpy
st7789
bme680
icm20948
as7262
max30105
vl53l5cx-ctypes
RPI.GPIO
adafruit-blinka
paho-mqtt
```
::: hint

Hinweis: Falls die Environment auf systemweite Installationen von Python Bibliotheken zugreifen soll, kann die Virtual Environment mit dem Flag `--system-site-packages` erstellt werden z.B. `python -m venv --system-site-packages ~/.env`. Dies ist beispielsweise bei Bibliotheken wie den SenseHat HAT erforderlich, die systemweit installiert werden. 

Hinweis: Um die Environment als solche in Jupyter Notebooks sichtbar zu machen, muss diese über die Installation von ipykernel hinzugefügt werden.

```bash
pip install ipykernel
python -m ipykernel install --user --name=.env --display-name "Python (.env)"
```
 
:::

## Konfigurationsdateien editieren
### Raspberry Pi Einstellungen für I2C, SPI, SSH, VNC anpassen
**Interface Options aktivieren** In den Raspberry Pi Konfigurationseinstellungen mit `sudo raspi-config` die Interface Optionen *I2C, SPI, SSH und ev VNC (Virtual Network Computing) oder RPi Connect* aktivieren. VNC, RPi Connect [@RaspberryPiLtd2024,@Hollingworth2024]^[RPI Connect erlaubt über einen Relay Server die Verbindung zu einem Raspberry Pi herzustellen über WebRTC wie Browser Clients für Zoom, Slack, Microsoft Teams. Der Relay Server wird nur für die Erstellung der Verbindung benötigt und wird von Raspberry Pi kostenlos betrieben. RPi Connect installieren mit `sudo apt install rpi-connect` und mit `sudo reboot` neu starten.] werden nur benötigt, wenn der Raspberry Pi über Fernzugriff gesteuert werden soll.

![Über die Konsole `raspi-config` starten und über das Konsolenmenu (links) die Einstellungen in den *Interface Options* (rechts) *I2C, SPI, SSH und ev VNC* aktivieren.](images/raspberry_pi_enable_ssh_spi_i2c.png)

### Baud rate des I2C Protokolls anpassen
Baud rate des I2C Protokolls mit `sudo nano /boot/firmware/config.txt` öffnen und folgende Zeile ergänzen. Mit `Ctrl+o` und  `Ctrl+x` speichern [siehe @RaspberryPiLtd2024a].

``` bash
dtparam=i2c_arm=on,i2c_arm_baudrate=400000
```
### Mosquitto Server Konfiguration
**Mosquitto Server Konfiguration** anpassen mit `sudo nano /etc/mosquitto/mosquitto.conf` und am Ende der Datei folgendes einfügen [@EclipseFoundation2021].

``` bash
listener 1883
allow_anonymous true
```
Mosquitto Server neu starten mit `sudo systemctl restart mosquitto`

**Node-Red Einstellungen initialisieren** mit `sudo node-red admin init`

- *yes* installation customise settings
- *yes* keep settings file at default location 
- *no* setup user security
- *yes* enable project features
- select *manual* workflow
- select *default theme*
- *yes* allow function nodes to load external modules

``` bash
Node-RED Settings File initialisation
=====================================
This tool will help you create a Node-RED settings file.
✔ Settings file · /root/.node-red/settings.js

User Security
=============
✔ Do you want to setup user security? · No

Projects
========
The Projects feature allows you to version control your flow using a local git repository.

✔ Do you want to enable the Projects feature? · Yes
✔ What project workflow do you want to use? · manual - you must manually commit changes

Editor settings
===============
✔ Select a theme for the editor. To use any theme other than "default", you will need to install @node-red-contrib-themes/theme-collection in your Node-RED user directory. · default
✔ Select the text editor component to use in the Node-RED Editor · monaco (default)

Node settings
=============
✔ Allow Function nodes to load external modules? (functionExternalModules) · Yes

Settings file written to /root/.node-red/settings.js
```

## Installationen testen und initialisieren

### Mosquitto Broker
Testen ob der Mosquitto Broker und Clients lokal auf dem Raspberry Pi funktionieren.
Erstelle einen Subscriber der für das Topic `iot/temperature` eine Subscription erstellt.
```bash 
mosquitto_sub -h 127.0.0.1 -v -t 'iot/temperature'
```
Öffne ein zweite Shell und erstelle einen Publisher für dasselbe Topic
```bash
mosquitto_pub -h 127.0.0.1 -t 'iot/temperature' -m 'Aussentemperatur: 22° Celsius'
```

### Node-Red
Node-Red Server testen : `<IP-Adresse>:1880` und über die Influxerweiterung sogenannte *Palette* die Erweiterung für InfluxDB installieren: *Hamburgermenu oben-rechts / Paletten verwalten* und unter *Palette* / *Installation* die Palette `node-red-contrib-influxdb` installieren.

![](images/5200_iot_nodered_influxdb_erweiterung.png)

### InfluxDB
InfluxDB Server testen: `<IP-Adresse>:8086` und den *Initial User* erstellen mit *Username, Password, Organisation* und einem *Bucket* Name, der ersten Datenbank. Im Anschluss mit Logout/Login den Zugang verifizieren.

![](images/5200_iot_influxdb_setup.png)

::: hint
**Operator API token speichern!** Das Superuser Passwort wird nur einmal angezeigt. Das **Operator API token** kopieren und an einem sicheren Ort speichern! Nach dem Logout/Login ist das Passwort nicht mehr sichtbar. 
:::

### Grafana
Grafana Server testen: `<IP-Adresse>:3000` aufrufen. Grafana startet mit dem Default Admin User: `admin` und Passwort: `admin`. Das Passwort ändern und im Anschluss mit Logout/Login den Zugang verifizieren.

![](images/5200_iot_grafana_setup.png)

### Jupyter Notebook
Jupyter Notebook testen `<IP-Adresse>:9999`
``` bash
# python virtual environment aktivieren
source ~/.env/bin/activate
# jupter notebook installation testen
jupyter-notebook --no-browser --ip=192.168.1.205 --port 9999 --notebook-dir ~/Documents
# Erstelle ein Jupyter Notebook mit folgendem Code
import numpy as np
# liste alle installierten Libraries auf
!pip list
```

### VNC Testen
VNC Viewer auf dem PC installieren. [Real VNC Viewer](https://www.realvnc.com/en/connect/download/viewer) (standalone .exe, d.h. es ist keine Installation erforderlich). 

**Hinweis:** Beim Starten des VNC Viewers muss man sich nicht anmelden sondern nur die Option **Verwenden Sie RealVNC Viewer ohne sich anzumelden** wählen.

![](images/raspberrypi_realvnc.png)

## Raspberry Pi Image verkleinern
Das Raspberry Pi Image kann mit dem Tool [PiShrink](https://github.com/Drewsif/PiShrink) verkleinert werden. PiShrink kann auf dem Raspberry Pi oder auf einen anderen Linux System wie Ubuntu oder einer virtuellen Machine mit einem Linux installiert und genutzt werden.

1. Auf dem Raspberry Pi `/etc/rc.local` aktivieren damit PiShrink das Dateisystem verkleinern kann. Auf neuen Rasperry Pi OS Versionen ist `/etc/rc.local` nicht mehr aktiviert.
2. Backup Image auf den lokalen Rechner mit [Win32DiskImager](https://sourceforge.net/projects/win32diskimager/) *lesen* und in eine Image Datei schreiben.
3. Virtuelle Machine mit Linux Ubuntu/Debian mit *gemeinsamen Ordner* starten
4. Mit dem Script https://github.com/Drewsif/PiShrink das Image verkleinern
5. SD Karte Formatieren mit [SD Card Formatter ](https://www.sdcard.org/downloads/formatter)
6. Image auf SD Karte schreiben mit *Win 32 Disk Imager* oder *Raspberry Pi Imager*
7. Für die Archivierung kann das Image mit 7zip zusätzlich komprimiert werden (Archive Format `.xz` und Kompressionsstufe `Ultra`)

Tutorial: 

- [How I Backup and Shrink My SD Card Images - Youtube](https://www.youtube.com/watch?v=5pdgO3Ncl6k)
- [How to Enable /etc/rc.local with Systemd](https://www.linuxbabe.com/linux-server/how-to-enable-etcrc-local-with-systemd)


`/etc/rc.local` auf dem Raspberry Pi aktivieren

```bash
# Teste ob /etc/rc.local aktiviert ist 
sudo systemctl status rc-local
# Test ob sich rc.local aktivieren lässt
sudo systemctl enable rc-local
```
Erstelle nun eine folgende Datei mit `sudo nano /etc/systemd/system/rc-local.service` mit folgendem Inhalt und speichere die Datei mit `Ctrl+o` und `Ctrl+x`.

```bash
[Unit]
 Description=/etc/rc.local Compatibility
 ConditionPathExists=/etc/rc.local

[Service]
 Type=forking
 ExecStart=/etc/rc.local start
 TimeoutSec=0
 StandardOutput=tty
 RemainAfterExit=yes
 SysVStartPriority=99

[Install]
 WantedBy=multi-user.target
```

Ändere die Rechte der Datei und aktiviere den Dienst mit folgenden Befehlen:
```bash
# Rechte der Datei anpassen
sudo chmod +x /etc/rc.local
# Falls eine Fehlermeldung, dass die Datei nicht existiert erscheint,
# erstelle die Datei mit folgendem Befehl (Ab Ubuntu 16.10)
printf '%s\n' '#!/bin/bash' 'exit 0' | sudo tee -a /etc/rc.local
sudo chmod +x /etc/rc.local
# Aktiviere dass der Dienst beim booten gestartet wird
sudo systemctl enable rc-local
# Starte den Dienst und teste ob der Dienst läuft
sudo systemctl start rc-local.service
sudo systemctl status rc-local.service
```


Backup Image mit Win32DiskImager schreiben, mit der Funktion *Lesen/Read* und diese als Image Datei auf den lokalen Rechner speichern.

![Backup Image der SD Karte schreiben mit Win32DiskImager und der Funktion *Lesen/Read*](images/raspberrypi_image_verkleinern_01.png)

Virtuelle Machine mit VM [VirtualBox](https://www.virtualbox.org/) starten^[Falls das Einrichten von Ubuntu auf VirtualBox Probleme bereitet und viel zu langsam ist (Hyper-V), dann hilft nach einer vorbereiteten .vbox Datei mit einem Ubuntu Image in der gewünschten Version zu suchen und diese zu nutzen.] und in den Einstellungen der VM über *Geräte/Gemeinsame Ordner* einen gemeinsamen Ordner zwischen VM und dem lokalen Rechner einrichten.

![Gemeinsamer Ordner in der VM VirtualBox einrichten](images/raspberrypi_image_verkleinern_02.png)

Das Image sollte nun im File Explorer unter "+ Other Locations" als Ordner *host* eingebunden und sichtbar sein.

![Gemeinsamer Ordner *host* auf der VM Virtualbox eingebunden](images/raspberrypi_image_verkleinern_03.png)

Öffne nun ein Terminal damit das Script `pishrink.sh` installiert und ausgeführt werden kann. 

**Tipp:** Terminal über `Ctrl+Alt+t` öffnen. Falls das Terminal nicht öffnet mit `Ctrl+Alt+F3` in das TTY Terminal wechseln, und `Ctrl+Alt+F2` um in die Desktop-Umgebung zurückzukehren.

**Tipp:** Falls der VM User noch keine Adminrechte hat (bei einer Neuinstallation von Ubuntu ist das `root` Passwort nocht nicht gesetzt), können diese nachträglich gesetzt werden mit `sudo passwd`. Bei der Passwortabfrage das aktuelle User Passwort eingeben und das neue Root Passwort zweimal eingeben. Anschliessend als Root User anmelden mit `su -`.^[Einem User Adminrechte zuweisen:  `sudo usermod -a -G sudo <username>`, Kontoinformationen `id <username>` aufzeigen.]

GitHub: <https://github.com/Drewsif/PiShrink>

```bash
# install prerequisites
sudo apt install parted xz-utils
# download the pishrink script
wget -O ./pishrink.sh https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
# make the script executable
chmod +x ./pishrink.sh
# run pishrink on the .img file
sudo ./pishrink.sh -v /host/<rpi-imagefile>.img
# Komprimiere die Image als .xz Archive (eher langsam)
xz -z -9e /host/<rpi-imagefile>.img
```
![Screenshot des Terminals während der Ausführung von pishrink](images/raspberrypi_image_verkleinern_04.png){width=50%}

Für die Archivierung des Images, kann das Image mit 7-Zip zusätzlich komprimiert werden. Im File Kontextmenu  *7-Zip/Add to Archive* und als Archive Format `.xz` sowie den Compression Level *9-Ultra* wählen und komprimieren.

![7-Zip Einstellungen für die zusätzliche Kompression des Images mit `.xz`.](images/raspberrypi_image_verkleinern_05.png){width=50%}

Falls die SD Karte schon früher für Raspberry Pi Images benutzt wurde und mehrerere Partionen aufweist, kann es helfen die Karte mit dem [SD Card Formatter](https://www.sdcard.org/downloads/formatter/) nochmals von Grund auf zu formatieren.

![Screenshot des SD Card Formatter](images/raspberrypi_image_verkleinern_06.png){width=50%}

Es empfiehlt sich das Image nochmals auf eine SD Karte zu schreiben und zu testen ob der Raspberry Pi mit dem Image startet. Und ob die Speichergrösse in etwas der Grösse der SD Karte entspricht.

```bash
# Überprüfe die Partitionen und deren Größe
df -h
# Oder mit POSIX Standard Ausgabe
LC_ALL=C POSIXLY_CORRECT=1 df -P
```

::: {.content-visible when-profile="chapter"}
## Referenzen
:::